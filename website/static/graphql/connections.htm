<!DOCTYPE html>
<!-- Built with spec-md https://spec-md.com -->
<html>
<head><meta charset="utf-8">
<title>GraphQL 커서 연결 사양</title>
<style>body {
  color: #333333;
  font: 13pt/18pt Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  margin: 6rem auto 3rem;
  max-width: 780px;
}

/* Selections */

.outdated-selection-link,
.selection-link {
  position: absolute;
  display: block;
  color: #fff;
  background: #cacee0;
  border-radius: 4px;
  font-size: 36px;
  height: 23px;
  line-height: 48px;
  text-align: center;
  text-decoration: none;
  width: 25px;
  user-select: none;
  -moz-user-select: none;
  -webkit-user-select: none;
  -ms-user-select: none;
}

.outdated-selection-link:hover,
.selection-link:hover {
  text-decoration: none;
}

.outdated-selection-link:before,
.selection-link:before {
  border: 5px solid transparent;
  border-left-color: #cacee0;
  border-right: 0;
  content: '';
  height: 0;
  margin-top: -5px;
  margin-right: -5px;
  position: absolute;
  right: 1px;
  top: 50%;
  width: 0;
}

.selection-link:hover {
  background: #3b5998;
}

.selection-link:hover:before {
  border-left-color: #3b5998;
}

.outdated-selection-link {
  background: #f0babe;
  font-size: 21px;
  font-weight: 800;
  line-height: 27px;
}

.outdated-selection-link:before {
  border-left-color: #f0babe;
}

.outdated-selection-link:hover:after {
  content: "This selection content has changed since this link was created.";
  font: 9pt/11pt Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  position: absolute;
  display: block;
  white-space: nowrap;
  padding: 2px 5px 1px;
  top: -20px;
  background: black;
  color: white;
}

/* Links */

a {
  color: #3B5998;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}


/* Section headers */

h1, h2, h3, h4, h5, h6, h7, h8 {
  font-weight: bold;
  margin: 3em 0 1em;
  position: relative;
}

h1 {
  font-size: 1.5em;
  margin: 6em 0 3em;
}

h2 {
  font-size: 1.5em;
  margin-top: 5em;
}

h3, h4 {
  font-size: 1.25em;
}

h5, h6 {
  font-size: 1em;
}

section.subsec > h6 {
  margin-top: 2em;
}

section.subsec > h6 > a {
  color: #333333;
}

section .spec-secid {
  margin-right: 1ex;
  position: absolute;
  right: 100%;
  text-align: right;
  white-space: nowrap;
}

footer {
  font-size: 75%;
  opacity: 0.5;
  text-align: center;
  margin-top: 12rem;
}


/* Table of contents */

.spec-toc {
  margin: 1rem 0 3rem;
}

.spec-toc .title {
  content: 'Contents';
  display: block;
  font-weight: bold;
  margin: 5em 0 1em;
}

.spec-toc .spec-secid {
  margin-right: 1ex;
}

.spec-toc ol {
  list-style: none;
  padding-left: 0;
}

.spec-toc ol ol {
  list-style: none;
  padding-left: 2ex;
}

.spec-toc li {
  position: relative;
  padding: 5px 0 0 30px;
  margin: -5px 0 0 -30px;
}

.spec-toc a {
  color: #333333;
}

.spec-toc a:hover {
  text-decoration: none;
}

.spec-toc a .spec-secid {
  color: #3B5998;
}

.spec-toc a:hover .spec-secid {
  text-decoration: underline;
}

.spec-toc .toggle {
  display: none;
}

.spec-toc .toggle + label {
  cursor: pointer;
  left: 10px;
  opacity: 1;
  padding: 3px 5px 3px 6px;
  position: absolute;
  top: 8px;
  transform: rotate(0deg);
  transition: all 0.18s ease-in-out;
}

.spec-toc .toggle + label:after {
  border-color: transparent transparent transparent #bbc;
  border-style: solid;
  border-width: 6px 0 6px 7px;
  content: ' ';
  display: block;
  height: 0;
  width: 0;
}

.spec-toc .toggle:checked + label {
  transform: rotate(90deg);
}

.spec-toc li:not(:hover) > .toggle:checked + label {
  opacity: 0;
}

.spec-toc .toggle:not(:checked) ~ ol {
  max-height: 0;
  overflow: hidden;
}


/* Sidebar */

.spec-sidebar-toggle {
  display: none;
}

.spec-sidebar-toggle + label {
  position: fixed;
  right: 0;
  top: 0;
  padding: 10px 15px;
  font-size: 30px;
  color: rgba(0,0,0,0.7);
  z-index: 2;
  cursor: pointer;
  user-select: none;
  -moz-user-select: none;
  -webkit-user-select: none;
  -ms-user-select: none;
}

.spec-sidebar {
  display: none;
  position: fixed;
  right: 0;
  top: 0;
  width: 320px;
  font-size: 80%;
  overflow-y: scroll;
  height: 100%;
  padding: 0 0 5rem 30px;
  box-sizing: border-box;
  background: #f0f0f0;
}

.spec-sidebar {
  user-select: none;
  -moz-user-select: none;
  -webkit-user-select: none;
  -ms-user-select: none;
}

.spec-sidebar-toggle:checked ~ .spec-sidebar {
  display: block;
  box-shadow:
    -1px 0 rgba(0,0,0,0.12),
    -4px 0 8px -2px rgba(0,0,0,0.05);
}

.spec-sidebar .viewing > a:after {
  color: #8b9;
  content: '\2022';
  margin-left: 1ex;
}

@media (min-width: 1240px) {
  .spec-sidebar-toggle + label {
    display: none;
  }

  .spec-sidebar {
    display: block;
    box-shadow:
      inset 1px 0 rgba(0,0,0,0.05),
      inset 4px 0 8px -2px rgba(0,0,0,0.08) !important;
  }

  body {
    padding-right: 300px;
  }
}


/* Notes */

.spec-note {
  background: #FEFEF3;
  border-left: solid 4px #F4E925;
  margin: 1em -1em;
  min-width: 416px;
  padding: 1ex 1em 1ex calc(1em - 4px);
  width: -moz-fit-content;
  width: -webkit-fit-content;
  width: fit-content;
}

.spec-note > a:first-child {
  color: #6C6613;
  display: block;
  font: italic 11pt/18pt Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  opacity: 0.6;
  user-select: none;
}


/* Todos */

.spec-todo {
  color: #666666;
  margin: 1em 0 1em 5em;
  min-height: 1em;
}

.spec-todo::before {
  content: 'todo';
  display: block;
  float: left;
  margin-left: -5em;
  text-transform: uppercase;
}

/* Index table */

.spec-index ol {
  list-style-type: none;
  margin: 0 0 0 2rem;
  padding: 0;
  column-width: 210px;
  column-gap: 2rem;
}

.spec-index ol li {
  width: min-content;
}

/* Code */

code {
  background: #FAFAFA;
  font-family: Consolas, Monaco, monospace;
  font-size: 85%;
  font-weight: inherit;
  margin: -2px -1px;
  padding: 3px 3px;
  white-space: pre;
}

pre code {
  background: none;
  font-weight: inherit;
  margin: 0;
  padding: 0;
}

pre {
  background: #FAFAFA;
  border-left: solid 4px #E9E9E9;
  margin: 1em -1em;
  min-width: 40ch;
  padding: 1ex 1em 1ex calc(1em - 4px);
  width: -moz-fit-content;
  width: -webkit-fit-content;
  width: fit-content;
}

.spec-example {
  background: #FAFAFF;
  border-left: solid 4px #BBBBFF;
}

.spec-counter-example {
  background: #FFFAFA;
  border-left: solid 4px #FFBBBB;
}

.spec-example > a,
.spec-counter-example > a {
  display: block;
  font: italic 11pt/18pt Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  opacity: 0.6;
  user-select: none;
}

.spec-counter-example > a {
  color: #98593b;
}


/* Tables */

table {
  border-collapse: collapse;
}

th {
  background-color: #F9F9F9;
}

td, th {
  border: 1px solid #D0D0D0;
  padding: 0.4em;
  vertical-align: baseline;
}


/* Edits */

ins {
  background-color: rgba(0, 200, 30, 0.08);
  text-decoration: none;
}

del {
  background-color: rgba(200, 0, 0, 0.08);
}

.spec-added, .spec-removed {
  border-left: 4px solid;
  margin-left: -18px;
  padding-left: 14px;
}

.spec-added {
  border-color: #396;
}

.spec-removed {
  border-color: #933;
  text-decoration: line-through;
}


/* Values */

.spec-keyword {
  font-weight: bold;
}

.spec-string {
  font-family: Consolas, Monaco, monospace;
  font-size: 85%;
  white-space: pre;
}

var {
  font-style: italic;
}

*[data-name] {
  transition: 0.15s background ease-out;
  border-radius: 2px;
  padding: 0 3px;
  margin: 0 -3px;
}


/* Grammar semantics, algorithms and calls */

.spec-semantic,
.spec-algo {
  margin: 1rem 0 1rem 2rem;
}

.spec-semantic > .spec-rhs {
  display: inline-block;
  margin-left: 1ex;
}

.spec-semantic > .spec-nt::after,
.spec-algo > .spec-call:first-child::after {
  content: ':';
  font-style: normal;
  font-weight: bold;
  margin-left: 1ex;
}

.spec-semantic ol, .spec-semantic ol ol ol ol,
.spec-algo ol, .spec-algo ol ol ol ol {
  list-style-type: decimal;
}

.spec-semantic ol ol, .spec-semantic ol ol ol ol ol,
.spec-algo ol ol, .spec-algo ol ol ol ol ol {
  list-style-type: lower-alpha;
}

.spec-semantic ol ol ol, .spec-semantic ol ol ol ol ol ol,
.spec-algo ol ol ol, .spec-algo ol ol ol ol ol ol {
  list-style-type: lower-roman;
}

.spec-call > a {
  color: inherit;
}


/* Grammar productions */

.spec-production {
  margin: 1rem 0 1rem 2rem;
}

.spec-production > .spec-nt::after {
  content: ':';
  font-style: normal;
  font-weight: bold;
  margin: 0 1ex;
}

.spec-semantic.d2 > .spec-nt::after,
.spec-production.d2 > .spec-nt::after {
  content: '::';
}

.spec-semantic.d3 > .spec-nt::after,
.spec-production.d3 > .spec-nt::after {
  content: ':::';
}

.spec-rhs {
  margin-left: 2rem;
}

.spec-oneof {
  display: inline;
}

.spec-oneof::before {
  content: 'one of';
  font-style: normal;
  font-weight: bold;
}

.spec-oneof > table {
  margin-left: 2rem;
}

.spec-oneof .spec-rhs {
  border: none;
  margin: 0;
  padding: 0 0.5em;
  vertical-align: baseline;
}

.spec-rhs .spec-constrained:not(:first-child),
.spec-rhs .spec-quantified:not(:first-child),
.spec-rhs .spec-nt:not(:first-child),
.spec-rhs .spec-t:not(:first-child),
.spec-rhs .spec-rx:not(:first-child),
.spec-rhs .spec-prose:not(:first-child),
.spec-rhs .spec-empty:not(:first-child),
.spec-rhs .spec-lookahead:not(:first-child) {
  margin-left: 1ex;
}

.spec-condition {
  font-size: 85%;
}

.spec-condition::before {
  content: '[if '
}

.spec-condition.not::before {
  content: '[if not '
}

.spec-condition::after {
  content: ']'
}

.spec-empty,
.spec-prose {
  color: #666666;
}

.spec-nt {
  font-style: italic;
}

.spec-nt > a {
  color: inherit;
}

.spec-quantifiers,
.spec-params {
  font-size: 65%;
  font-style: normal;
  vertical-align: sub;
}

.spec-quantifier.list {
  color: #3348D3;
}

.spec-quantifier.optional {
  color: #83238E;
}

.spec-params,
.spec-condition {
  color: #1C7758;
}

.spec-params::before {
  content: '[';
}

.spec-params::after {
  content: ']';
}

.spec-quantifier:not(:last-child)::after,
.spec-param:not(:last-child)::after {
  color: #666666;
  content: ', ';
}

.spec-param.conditional::before {
  content: '?';
}

.spec-param.negated::before {
  content: '!';
}

.spec-t, .spec-rx {
  color: #333333;
  font-family: monospace;
  font-weight: bold;
}

.spec-butnot::before {
  color: #666666;
  content: 'but not';
  font-family: Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  font-weight: normal;
  margin-right: 1ex;
}

.spec-butnot > *:not(:first-child)::before {
  color: #666666;
  content: 'or';
  font-family: Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  font-weight: normal;
  margin-right: 1ex;
}

.spec-rhs .spec-oneof::before,
.spec-rhs .spec-butnot::before {
  margin-left: 1ex;
}

.spec-lookahead > * {
  margin: 0 !important;
}

.spec-lookahead > *:not(:first-child)::before {
  color: #666666;
  content: ', ';
  font-family: Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  font-style: normal;
  font-weight: normal;
}

.spec-lookahead::before {
  color: #666666;
  content: '[lookahead = ';
  font-family: Cambria, "Palatino Linotype", Palatino, "Liberation Serif", serif;
  font-style: normal;
  font-weight: normal;
}

.spec-lookahead.not::before {
  content: '[lookahead \2260  ';
}

.spec-lookahead.set::before {
  content: '[lookahead \2208  {';
  margin-right: 0;
}

.spec-lookahead.set.not::before {
  content: '[lookahead \2209  {';
}

.spec-lookahead.ntset::before {
  content: '[lookahead \2208  ';
  margin-right: 0;
}

.spec-lookahead.ntset.not::before {
  content: '[lookahead \2209  ';
}

.spec-lookahead::after {
  color: #666666;
  content: ']';
}

.spec-lookahead.set::after {
  content: '}]';
}
</style>
<style>/* Copied from node_modules/prismjs/themes/prism.css */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: black;
	background: none;
	text-shadow: 0 1px white;
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #f5f2f0;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #999;
}

.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
	color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
	color: #a67f59;
	background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: #07a;
}

.token.function {
	color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
	color: #e90;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}
</style>
<script>(function(){var e,t=document.getElementsByTagName("style")[0].sheet;function n(){e&&(t.deleteRule(e),e=void 0)}document.documentElement.addEventListener("mouseover",(function(a){var u,d=a.target.attributes["data-name"];d&&(u=d.value,n(),e=t.insertRule('*[data-name="'+u+'"] { background: #FBF8D0; }',t.cssRules.length))})),document.documentElement.addEventListener("mouseout",n);})()</script>
<script>(function(){var e,n,t,o,r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";function a(e){c(new URL(e.target.href))}function i(){c(window.location)}function c(e){var n=e.hash.match(/^#sel-([A-Za-z0-9-_]+)$/);if(n){o=n[1];var a=(t=function(e){for(var n=new Array(64),t=0;t<64;t++)n[r.charCodeAt(t)]=t;var o=0,a=m(),i=m(),c=m(),d=w(),l=i.pop(),f=u(a.concat(i)),h=c.pop(),g=u(a.concat(c)),v=document.createRange();return v.setStart(f,l),v.setEnd(g,h),v.isOutdated=void 0!==d&&d!==s(v.toString()),v;function w(){for(var t=0,r=0;o<e.length;){var a=n[e.charCodeAt(o++)];if(t|=(31&a)<<r,r+=5,a<32)return t}}function m(){var e=w();if(null!=e){for(var n=new Array(e),t=0;t<e;t++)n[t]=w();return n}}}(o)).getBoundingClientRect(),i=Math.max(20,Math.floor(.4*(window.innerHeight-a.height)));window.scrollTo(0,window.scrollY+a.y-i);var c=document.getSelection();c.empty(),c.addRange(t),d()}}function d(){n||(n=document.getElementsByTagName("article")[0]),e||(e=document.createElement("a"),document.body.appendChild(e)),e.href="#sel-"+o,e.onclick=a,e.className=t.isOutdated?"outdated-selection-link":"selection-link",e.innerText=t.isOutdated?"!":"‟";var r=n.getBoundingClientRect().x,i=t.getBoundingClientRect().y;e.style.left=Math.floor(r+window.scrollX-37)+"px",e.style.top=Math.floor(i+window.scrollY-3)+"px"}function l(e){for(var n=[];e!=document.body;){var t=e.parentNode;n.push(Array.prototype.indexOf.call(t.childNodes,e)),e=t}return n.reverse()}function u(e){for(var n=document.body,t=0;t<e.length&&n;t++)n=n.childNodes[e[t]];return n}function s(e){for(var n=2166136261,t=0;t<e.length;++t)n^=e.charCodeAt(t),n+=(n<<1)+(n<<4)+(n<<7)+(n<<8)+(n<<24);return 32767&(n>>15^n)}document.addEventListener("selectionchange",(function(n){var a=document.getSelection();if(a.isCollapsed)e&&(e.parentNode.removeChild(e),e=null);else{var i=a.getRangeAt(0);t&&0===i.compareBoundaryPoints(Range.START_TO_START,t)&&0===i.compareBoundaryPoints(Range.END_TO_END,t)||(o=function(e){var n="",t=l(e.startContainer),o=l(e.endContainer),a=function(e,n){var t=0;for(;t<e.length&&t<n.length&&e[t]===n[t];)t++;return e.slice(0,t)}(t,o);return c(a),c(t.slice(a.length).concat(e.startOffset)),c(o.slice(a.length).concat(e.endOffset)),i(s(e.toString())),n;function i(e){do{n+=r[31&e|(e>31?32:0)],e>>=5}while(e>0)}function c(e){i(e.length);for(var n=0;n<e.length;n++)i(e[n])}}(t=i),d())}})),window.addEventListener("resize",d),window.addEventListener("hashchange",i),window.addEventListener("load",i);})()</script>
</head>
<body><article>
<header>
<h1>GraphQL 커서 연결 사양</h1>
<section id="intro">
<p>본 문서는 GraphQL 클라이언트가 GraphQL 서버를 통해 관련 메타데이터를 지원하면서 <a href="https://graphql.org/learn/pagination/">페이지네이션의 모범 사례</a>를 일관되게 처리하는 방법을 제공하는 것을 목표로 합니다. 본 문서는 이러한 패턴을 &ldquo;커넥션&rdquo;이라 부르고 표준화된 방식으로 노출하는 것을 제안합니다.</p>
<p>쿼리에서 이 커넥션 모델은 결과 집합에 슬라이싱과 페이지네이션을 하는 표준 메커니즘을 제공합니다. </p>
<p>응답에선 이 커넥션 모델은 커서를 제공하는 표준화된 방법과 더 많은 리턴 값이 사용 가능할 때 클라이언트에게 알려주는 방법을 제공합니다.</p>
<p>다음 쿼리는 이러한 것들의 네 가지 예시입니다.</p>
<pre><code><span class="token punctuation">{</span>
  user <span class="token punctuation">{</span>
    id
    name
    friends<span class="token punctuation">(</span><span class="token attr-name">first</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token attr-name">after</span><span class="token punctuation">:</span> <span class="token string">"opaqueCursor"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      edges <span class="token punctuation">{</span>
        cursor
        node <span class="token punctuation">{</span>
          id
          name
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      pageInfo <span class="token punctuation">{</span>
        hasNextPage
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>이 예시에서, <code>friends</code>는 커넥션입니다. 이 쿼리는 위에서 설명한 네 가지 특징을 보여줍니다.</p>
<ul>
<li>슬라이싱은 <code>friends</code>에 있는 <code>first</code> 인자 값으로 결정됩니다. 위 쿼리에선 커넥션에게 10명의 친구를 리턴해달라고 요청합니다.</li>
<li>페이지네이션은 <code>friends</code>에 있는 <code>after</code> 인자 값으로 결정됩니다. 커서를 전달했기 때문에, 서버에게 커서 뒤에 있는 친구를 리턴해달라고 요청했습니다.</li>
<li>커넥션에 있는 각 엣지에서 커서를 요청했습니다. 이 커서는 불투명 스트링이고, 정확히 엣지 이후부터 시작으로 페이징하기 위해 <code>after</code> 인자에 전달할 것입니다.</li>
<li><code>hasNextPage</code>를 요청했습니다. <code>hasNextPage</code>는 사용 가능한 엣지가 있다거나 이 커넥션의 끝에 도착한다면 알려줄 것입니다.</li>
</ul>
<p>이 섹션에서는 커넥션과 관련된 공식적인 요구사항을 설명합니다.</p>
</section>
<nav class="spec-toc">
<div class="title">Contents</div>
<ol>
<li><a href="#sec-undefined.-"><span class="spec-secid">1</span>예약된 타입</a></li>
<li><a href="#sec-undefined.-"><span class="spec-secid">2</span>커넥션 타입</a>
<input hidden class="toggle" type="checkbox" checked id="_toggle_2" /><label for="_toggle_2"></label>
<ol>
<li><a href="#sec-undefined.-.-"><span class="spec-secid">2.1</span>필드</a>
<input hidden class="toggle" type="checkbox" checked id="_toggle_2.1" /><label for="_toggle_2.1"></label>
<ol>
<li><a href="#sec-undefined.-.-.-"><span class="spec-secid">2.1.1</span>엣지</a></li>
<li><a href="#sec-PageInfo-"><span class="spec-secid">2.1.2</span>PageInfo 필드</a></li>
</ol>
</li>
<li><a href="#sec-undefined.-.-"><span class="spec-secid">2.2</span>스키마 확인</a></li>
</ol>
</li>
<li><a href="#sec-undefined.-"><span class="spec-secid">3</span>엣지 타입</a>
<input hidden class="toggle" type="checkbox" checked id="_toggle_3" /><label for="_toggle_3"></label>
<ol>
<li><a href="#sec-undefined.-.-"><span class="spec-secid">3.1</span>필드</a>
<input hidden class="toggle" type="checkbox" checked id="_toggle_3.1" /><label for="_toggle_3.1"></label>
<ol>
<li><a href="#sec-undefined.-.-.-"><span class="spec-secid">3.1.1</span>노드</a></li>
<li><a href="#sec-undefined.-.-.-"><span class="spec-secid">3.1.2</span>커서</a></li>
</ol>
</li>
<li><a href="#sec-undefined.-.-"><span class="spec-secid">3.2</span>스키마 확인</a></li>
</ol>
</li>
<li><a href="#sec-undefined.-"><span class="spec-secid">4</span>인수</a>
<input hidden class="toggle" type="checkbox" checked id="_toggle_4" /><label for="_toggle_4"></label>
<ol>
<li><a href="#sec-undefined.-.-"><span class="spec-secid">4.1</span>정방향 페이지네이션의 인수</a></li>
<li><a href="#sec-undefined.-.-"><span class="spec-secid">4.2</span>역방향 페이지네이션의 인수</a></li>
<li><a href="#sec-undefined.-.-"><span class="spec-secid">4.3</span>엣지 순서</a></li>
<li><a href="#sec-undefined.-.-"><span class="spec-secid">4.4</span>페이지네이션 알고리즘</a></li>
</ol>
</li>
<li><a href="#sec-PageInfo"><span class="spec-secid">5</span>PageInfo</a>
<input hidden class="toggle" type="checkbox" checked id="_toggle_5" /><label for="_toggle_5"></label>
<ol>
<li><a href="#sec-PageInfo.-"><span class="spec-secid">5.1</span>필드</a></li>
<li><a href="#sec-PageInfo.-"><span class="spec-secid">5.2</span>스키마 확인</a></li>
</ol>
</li>
<li><a href="#index"><span class="spec-secid">§</span>Index</a></li>
</ol>
</nav>
</header>
<section id="sec-undefined.-" secid="1">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-">1</a></span>예약된 타입</h2>
<p>이 스펙을 준수하는 GraphQL 서버는 커넥션의 페이지네이션 모델을 지원하기 위해 특정 타입과 타입 이름을 정해두고 있어야 합니다. 특히, 이 스펙은 다음 타입에 관한 가이드라인을 제공합니다.</p>
<ul>
<li>이름이 &ldquo;Connection&rdquo;으로 끝나는 모든 오브젝트.</li>
<li><code>PageInfo</code>라는 이름의 오브젝트.</li>
</ul>
</section>
<section id="sec-undefined.-" secid="2">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-">2</a></span>커넥션 타입</h2>
<p>본 스펙에서는 &ldquo;Connection&rdquo;으로 끝나는 이름을 가진 모든 타입은 <em>커넥션 타입</em> 으로 간주됩니다. 커넥션 타입은 GraphQL 기술서의 &ldquo;타입 시스템&rdquo; 섹션에 정의된 &ldquo;오브젝트&rdquo;여야 합니다.</p>
<section id="sec-undefined.-.-" secid="2.1">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-">2.1</a></span>필드</h3>
<p>커넥션 타입은 <code>edges</code>와 <code>pageInfo</code>라는 필드를 가져야 합니다. 스키마 설계자가 적합하다고 판단이 되면, 커넥션과 관련된 추가적인 필드를 가질 수 있습니다.</p>
<section id="sec-undefined.-.-.-" secid="2.1.1">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-.-">2.1.1</a></span>엣지</h4>
<p>&rdquo;커넥션 타입&rdquo;은 <code>edges</code>라는 필드를 포함해야 합니다. 이 필드는 엣지 타입을 감싸는 리스트 타입을 리턴해야 합니다. 이 엣지 타입의 요구사항은 아래 &ldquo;엣지 타입&rdquo; 섹션에 정의되어 있습니다.</p>
</section>
<section id="sec-PageInfo-" secid="2.1.2">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-PageInfo-">2.1.2</a></span>PageInfo 필드</h4>
<p>&rdquo;커넥션 타입&rdquo;은 <code>pageInfo</code>라는 필드를 포함해야 합니다. 이 필드는 밑의 &ldquo;PageInfo&rdquo; 섹션에 정의된 것처럼 null이 아닌 <code>pageInfo</code> 오브젝트를 리턴해야 합니다.</p>
</section>
</section>
<section id="sec-undefined.-.-" secid="2.2">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-">2.2</a></span>스키마 확인</h3>
<p><code>ExampleConnection</code>이 타입 시스템에 존재한다면, 이름이 &ldquo;Connection&rdquo;으로 끝나기 때문에 커넥션이 될 것입니다. 만약 이 커넥션의 엣지 타입이 <code>ExampleEdge</code>라고 이름 지어졌다면, 위의 요구사항을 올바르게 구현한 서버는 아래의 스키마 확인 쿼리를 받아들일 것이고, 아래처럼 제공된 응답을 리턴할 것입니다.</p>
<pre><code><span class="token punctuation">{</span>
  __type<span class="token punctuation">(</span><span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token string">"ExampleConnection"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fields <span class="token punctuation">{</span>
      name
      <span class="token keyword">type</span> <span class="token punctuation">{</span>
        name
        kind
        ofType <span class="token punctuation">{</span>
          name
          kind
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>리턴</p>
<pre><code><span class="token punctuation">{</span>
  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"__type"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token property">"fields"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token comment">// May contain other items</span>
        <span class="token punctuation">{</span>
          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"pageInfo"</span><span class="token punctuation">,</span>
          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>
            <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"NON_NULL"</span><span class="token punctuation">,</span>
            <span class="token property">"ofType"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"PageInfo"</span><span class="token punctuation">,</span>
              <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"OBJECT"</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span>
          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"edges"</span><span class="token punctuation">,</span>
          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>
            <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"LIST"</span><span class="token punctuation">,</span>
            <span class="token property">"ofType"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"ExampleEdge"</span><span class="token punctuation">,</span>
              <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"OBJECT"</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
</section>
<section id="sec-undefined.-" secid="3">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-">3</a></span>엣지 타입</h2>
<p>커넥션 타입의 엣지 필드에서 리스트 형식으로 리턴된 타입은 본 스펙에 의해 <em>엣지 타입</em> 이라고 간주됩니다. 엣지 타입은 반드시 GraphQL 기술서의 &ldquo;타입 시스템&rdquo; 섹션에 정의된 대로 &ldquo;오브젝트&rdquo;여야 합니다. </p>
<section id="sec-undefined.-.-" secid="3.1">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-">3.1</a></span>필드</h3>
<p>엣지 타입은 <code>node</code>와 <code>cursor</code>라는 필드를 가져야 합니다. 스키마 설계자가 적합하다고 판단이 되면 엣지와 관련된 추가적인 필드를 가질 수도 있습니다.</p>
<section id="sec-undefined.-.-.-" secid="3.1.1">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-.-">3.1.1</a></span>노드</h4>
<p>&rdquo;엣지 타입&rdquo;은 <code>node</code>라는 필드를 포함해야 합니다. 이 필드는 반드시 스칼라, Enum, 오브젝트, 인터페이스, 유니온 또는 이 타입 중 하나를 감싸는 null이 아닌 래퍼 중 하나를 리턴해야 합니다. 특히 이 필드는 <em>리스트를 리턴할 수 없습니다.</em></p>
<div id="note-aae7a" class="spec-note">
<a href="#note-aae7a">Note</a>
네이밍은 이 스펙의 마지막에 설명된 대로 &ldquo;Node&rdquo; 인터페이스와 &ldquo;node&rdquo; 루트 필드를 반영합니다. 이 필드가 노드를 상속받은 오브젝트를 리턴한다면 스펙을 충족하는 클라이언트는 특정한 최적화를 수행할 수 있습니다만, 이는 스펙 준수를 위한 엄격한 요구사항은 아닙니다.</div>
</section>
<section id="sec-undefined.-.-.-" secid="3.1.2">
<h4><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-.-">3.1.2</a></span>커서</h4>
<p>&rdquo;엣지 타입&rdquo;은 <code>cursor</code>라는 필드를 포함해야 합니다. 이 필드는 문자열로 직렬화한 타입을 리턴해야 합니다. 이 커서 필드는 String 타입이거나 String을 둘러싼 null이 아닌 wrapper, 문자열을 직렬화한 커스텀 스칼라 또는 String으로 직렬화한 커스텀 스칼라 타입으로 둘러싼 null이 아닌 wrapper 중 하나일 수 있습니다.</p>
<p>이 필드가 리턴하는 타입을 이후의 스펙 문서에서는 <em>커서 타입</em>이라 하겠습니다.</p>
<p>이 필드의 결과는 클라이언트에게는 불투명하게 간주되어야 합니다만, 아래의 &ldquo;인수&rdquo; 섹션에서 설명한 것처럼 서버로 다시 전달됩니다.</p>
</section>
</section>
<section id="sec-undefined.-.-" secid="3.2">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-">3.2</a></span>스키마 확인</h3>
<p>&ldquo;Example&rdquo; 오브젝트를 리턴하는 스키마에서 <code>ExampleEdge</code>이 엣지 타입이라면, 위의 요구사항을 정확하게 충족하는 서버는 스키마 확인 쿼리를 받아들이고 주어진 응답을 리턴합니다.</p>
<pre><code><span class="token punctuation">{</span>
  __type<span class="token punctuation">(</span><span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token string">"ExampleEdge"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fields <span class="token punctuation">{</span>
      name
      <span class="token keyword">type</span> <span class="token punctuation">{</span>
        name
        kind
        ofType <span class="token punctuation">{</span>
          name
          kind
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>리턴</p>
<pre><code><span class="token punctuation">{</span>
  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"__type"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token property">"fields"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token comment">// May contain other items</span>
        <span class="token punctuation">{</span>
          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"node"</span><span class="token punctuation">,</span>
          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Example"</span><span class="token punctuation">,</span>
            <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"OBJECT"</span><span class="token punctuation">,</span>
            <span class="token property">"ofType"</span><span class="token operator">:</span> <span class="token null keyword">null</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span>
          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"cursor"</span><span class="token punctuation">,</span>
          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token comment">// This shows the cursor type as String!, other types are possible</span>
            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>
            <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"NON_NULL"</span><span class="token punctuation">,</span>
            <span class="token property">"ofType"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"String"</span><span class="token punctuation">,</span>
              <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"SCALAR"</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
</section>
<section id="sec-undefined.-" secid="4">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-">4</a></span>인수</h2>
<p><em>커넥션 타입</em>을 리턴하는 필드는 반드시 정방향 페이지네이션의 인수를 가져야 하거나 역방향 페이지네이션의 인수 또는 역방향, 정방향 페이지네이션 인수 둘 다 가지고 있어야 합니다. 이러한 페이지네이션 인수는 리턴하기 전에 클라이언트가 엣지 세트를 자를 수 있도록 합니다.</p>
<section id="sec-undefined.-.-" secid="4.1">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-">4.1</a></span>정방향 페이지네이션의 인수</h3>
<p>정방향 페이지네이션을 하려면, 두 개의 인수가 필요합니다.</p>
<ul>
<li><code>first</code> : 음수가 아닌 정수.</li>
<li><code>after</code> : <code>cursor</code> 필드 섹션에 설명되어 있는 <em>커서 타입</em></li>
</ul>
<p>서버는 커넥션에 의해 리턴되는 엣지를 수정하기 위해 두 인수를 사용해야 합니다. <code>after</code> 커서 뒤의 엣지를 리턴하고 최대 <code>first</code> 엣지만큼 리턴해야 합니다.</p>
<p>일반적으로 <code>after</code>에 이전 페이지에 있는 마지막 엣지의 <code>cursor</code>를 전달해야 합니다.</p>
</section>
<section id="sec-undefined.-.-" secid="4.2">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-">4.2</a></span>역방향 페이지네이션의 인수</h3>
<p>역방향 페이지네이션을 하려면 두 개의 인수가 필요합니다.</p>
<ul>
<li><code>last</code> : 음수가 아닌 정수.</li>
<li><code>before</code> : <code>cursor</code> 필드 섹션에 설명되어 있는 <em>커서 타입</em>.</li>
</ul>
<p>서버는 커넥션에 의해 리턴되는 엣지를 수정하기 위해 두 인수를 사용해야 합니다. <code>before</code> 커서 앞의 엣지를 리턴하고 최대 <code>last</code>엣지만큼 리턴해야 합니다.</p>
<p>일반적으로 <code>before</code>에 다음 페이지에 있는 첫 번째 엣지의 <code>cursor</code>를 전달해야 합니다.</p>
</section>
<section id="sec-undefined.-.-" secid="4.3">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-">4.3</a></span>엣지 순서</h3>
<p>비즈니스 로직이 가르키는 대로 엣지의 순서를 정할 수 있고, 본 문서에서 다루지 않은 추가적인 인수로 순서를 결정할 수 있습니다. 그러나 순서는 반드시 페이지마다 일관되어야 하며, 중요한 것은 <em><code>first</code>/<code>after</code>를 사용할 때와 마찬가지로 <code>last</code>/<code>before</code>를 사용할 때 엣지의 순서는 똑같아야 하고, 다른 모든 인수는 동일해야 합니다.</em> <code>last</code>/<code>before</code>를 사용할 때는 거꾸로 되어 있으면 안 됩니다. 좀 더 공식적으론</p>
<ul>
<li><code>before: cursor</code>가 사용될 때, <code>cursor</code>와 가장 가까운 엣지는 반드시 <code>엣지</code> 결과의 가장 <strong>마지막</strong>에 와야 합니다.</li>
<li><code>after: cursor</code>가 사용될 땐, <code>cursor</code>와 가장 가까운 엣지는 반드시 <code>엣지</code> 결과의 <strong>첫 번째</strong>로 와야 합니다</li>
</ul>
</section>
<section id="sec-undefined.-.-" secid="4.4">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-undefined.-.-">4.4</a></span>페이지네이션 알고리즘</h3>
<p>어떤 엣지를 리턴할지 결정하기 위해선, 커넥션은 엣지를 거르기 위해 <code>before</code> 와 <code>after</code> 커서를 평가합니다. 그다음 엣지를 자르기 위해 <code>first</code>를 평가한 후 <code>last</code>를 평가하여 엣지를 자릅니다.</p>
<div id="note-009b3" class="spec-note">
<a href="#note-009b3">Note</a>
<code>first</code> 와 <code>last</code>를 둘 다 가지는 것은 쿼리와 결과가 혼동될 수 있기에 강력히 권장하지 않습니다. 이 부분은 <code>PageInfo</code> 섹션에서 좀 더 자세히 설명합니다.</div>
<p>조금 더 공식적으로,</p>
<div class="spec-algo" id="EdgesToReturn()">
<span class="spec-call"><a href="#EdgesToReturn()" data-name="EdgesToReturn">EdgesToReturn</a>(<var data-name="allEdges">allEdges</var>, <var data-name="before">before</var>, <var data-name="after">after</var>, <var data-name="first">first</var>, <var data-name="last">last</var>)</span><ol>
<li><var data-name="edges">edges</var>를 ApplyCursorsToEdges(allEdges, before, after) 의 결과로 둡니다.</li>
<li>만약 <var data-name="first">first</var> 가 set면:<ol>
<li>만약 <var data-name="first">first</var> 가 0 보다 작다면:<ol>
<li>에러를 발생시킵니다</li>
</ol>
</li>
<li>만약 <var data-name="edges">edges</var>가 <var data-name="first">first</var>보다 더 긴 길이를 가진 경우:<ol>
<li><var data-name="edges">edges</var>의 끝에서 부터 엣지를 제거하여 <var data-name="edges">edges</var>와 <var data-name="first">first</var>의 길이가 같도록 자릅니다</li>
</ol>
</li>
</ol>
</li>
<li>만약 <var data-name="last">last</var> 가 set면:<ol>
<li>만약 <var data-name="last">last</var> 가 0 보다 작다면:<ol>
<li>에러를 발생시킵니다</li>
</ol>
</li>
<li>만약 <var data-name="edges">edges</var>가 <var data-name="last">last</var>보다 더 긴 길이를 가진 경우:<ol>
<li><var data-name="edges">edges</var>의 시작에서 부터 엣지를 제거하여 <var data-name="edges">edges</var>와 <var data-name="last">last</var>의 길이가 같도록 자릅니다</li>
</ol>
</li>
</ol>
</li>
<li><var data-name="edges">edges</var>를 리턴합니다</li>
</ol>
</div>
<div class="spec-algo" id="ApplyCursorsToEdges()">
<span class="spec-call"><a href="#ApplyCursorsToEdges()" data-name="ApplyCursorsToEdges">ApplyCursorsToEdges</a>(<var data-name="allEdges">allEdges</var>, <var data-name="before">before</var>, <var data-name="after">after</var>)</span><ol>
<li><var data-name="edges">edges</var>를 <var data-name="allEdges">allEdges</var>로 초기화</li>
<li>만약 <var data-name="after">after</var> 가 set면:<ol>
<li><var data-name="afterEdge">afterEdge</var>를 <var data-name="cursor">cursor</var>와 <var data-name="after">after</var>의 인수가 동일한 <var data-name="edges">edges</var>의 엣지로 합니다</li>
<li>만약 <var data-name="afterEdge">afterEdge</var>가 존재한다면 :<ol>
<li><var data-name="afterEdge">afterEdge</var>를 포함하여 이전 <var data-name="edges">edges</var>의 모든 요소를 제거합니다</li>
</ol>
</li>
</ol>
</li>
<li>만약 <var data-name="before">before</var> 가 set면:<ol>
<li><var data-name="beforeEdge">beforeEdge</var>를 <var data-name="cursor">cursor</var>와 <var data-name="before">before</var>의 인수가 동일한 <var data-name="edges">edges</var>의 엣지로 합니다</li>
<li>만약 <var data-name="beforeEdge">beforeEdge</var> 가 존재한다면 :<ol>
<li><var data-name="beforeEdge">beforeEdge</var>를 포함하여 이후 <var data-name="edges">edges</var>의 모든 요소를 제거합니다</li>
</ol>
</li>
</ol>
</li>
<li><var data-name="edges">edges</var>를 리턴합니다</li>
</ol>
</div>
</section>
</section>
<section id="sec-PageInfo" secid="5">
<h2><span class="spec-secid" title="link to this section"><a href="#sec-PageInfo">5</a></span>PageInfo</h2>
<p>서버는 <code>PageInfo</code>라는 필드를 제공해야 합니다.</p>
<section id="sec-PageInfo.-" secid="5.1">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-PageInfo.-">5.1</a></span>필드</h3>
<p><code>PageInfo</code>는 반드시 <code>hasPreviousPage</code> 와 <code>hasNextPage</code>라는 필드를 포함해야 합니다. 이 두 필드는 null이 아닌 boolean를 리턴합니다. 또한 <code>startCursor</code> 와 <code>endCursor</code> 라는 필드도 포함해야 합니다. 이 두 개의 필드는 null이 아닌 불투명 string을 리턴합니다.</p>
<p><code>hasPreviousPage</code>는 클라이언트의 인수에 의해 집합이 정의되기 전에 더 많은 엣지가 존재하는지 나타내는데 사용됩니다. 클라이언트가 <code>last</code>/<code>before</code>로 페이지네이션을 하는 경우, 이전 엣지가 존재한다면 서버는 반드시 <span class="spec-keyword">true</span>를 리턴해야 하고, 그렇지 않다면 <span class="spec-keyword">false</span>를 리턴해야 합니다. 클라이언트가 <code>first</code>/<code>after</code>로 페이지네이션을 하는 경우, <code>after</code> 전에 엣지가 존재한다면 클라이언트는 <span class="spec-keyword">true</span>를 리턴할 것이고, 효율적으로 할 수 있으면 <span class="spec-keyword">false</span>를 리턴할 수 있습니다. 좀 더 공식적으론</p>
<div class="spec-algo" id="HasPreviousPage()">
<span class="spec-call"><a href="#HasPreviousPage()" data-name="HasPreviousPage">HasPreviousPage</a>(<var data-name="allEdges">allEdges</var>, <var data-name="before">before</var>, <var data-name="after">after</var>, <var data-name="first">first</var>, <var data-name="last">last</var>)</span><ol>
<li>만약 <var data-name="last">last</var> 가 집합이면 :<ol>
<li><var data-name="edges">edges</var>를 <span class="spec-call"><a href="#ApplyCursorsToEdges()" data-name="ApplyCursorsToEdges">ApplyCursorsToEdges</a>(<var data-name="allEdges">allEdges</var>, <var data-name="before">before</var>, <var data-name="after">after</var>)</span>의 호출 결과로 정해둡니다</li>
<li>만약 <var data-name="edges">edges</var>가 <var data-name="last">last</var>의 요소보다 많이 포함한다면 <span class="spec-keyword">true</span>를 리턴하고 아니면 <span class="spec-keyword">false</span>를 리턴합니다</li>
</ol>
</li>
<li>만약 <var data-name="after">after</var> 가 집합이면 :<ol>
<li>만약 서버가 <var data-name="after">after</var> 이전에 요소가 존재하는지 효율적으로 알 수 있으면 <span class="spec-keyword">true</span>를 리턴합니다</li>
</ol>
</li>
<li><span class="spec-keyword">false</span>를 리턴합니다</li>
</ol>
</div>
<p><code>hasNextPage</code>는 클라이언트 인수에 의해 정의된 집합 뒤에 더 많은 엣지가 존재하는지 나타내는데 사용됩니다. 클라이언트가 <code>first</code>/<code>after</code>로 페이지네이션을 하는 경우, 추가적인 엣지가 존재한다면 <span class="spec-keyword">true</span>를 리턴하고, 그렇지 않다면 <span class="spec-keyword">false</span>를 리턴합니다. 클라이언트가 <code>last</code>/<code>before</code>로 페이지네이션을 하는 경우, <code>before</code> 뒤에 엣지가 존재한다면 클라이언트는 <span class="spec-keyword">true</span>를 리턴할 것이고, 더 효율적으로 할 수 있으면 <span class="spec-keyword">false</span>를 리턴합니다. 좀 더 공식적으론</p>
<div class="spec-algo" id="HasNextPage()">
<span class="spec-call"><a href="#HasNextPage()" data-name="HasNextPage">HasNextPage</a>(<var data-name="allEdges">allEdges</var>, <var data-name="before">before</var>, <var data-name="after">after</var>, <var data-name="first">first</var>, <var data-name="last">last</var>)</span><ol>
<li>만약 <var data-name="first">first</var> 가 set면 :<ol>
<li><var data-name="edges">edges</var>를 <span class="spec-call"><a href="#ApplyCursorsToEdges()" data-name="ApplyCursorsToEdges">ApplyCursorsToEdges</a>(<var data-name="allEdges">allEdges</var>, <var data-name="before">before</var>, <var data-name="after">after</var>)</span>의 호출한 결과로 둡니다.</li>
<li>만약 <var data-name="edges">edges</var>가 <var data-name="first">first</var> 요소보다 많이 가지고 있으면 <span class="spec-keyword">true</span>를 리턴하고 아니면 <span class="spec-keyword">false</span>를 리턴합니다</li>
</ol>
</li>
<li>만약 <var data-name="before">before</var> 가 set:<ol>
<li>만약 서버가 <var data-name="before">before</var> 후에 요소가 존재하는지 효율적으로 알 수 있으면 <span class="spec-keyword">true</span>를 리턴합니다 </li>
</ol>
</li>
<li><span class="spec-keyword">false</span>를 리턴</li>
</ol>
</div>
<div id="note-c804e" class="spec-note">
<a href="#note-c804e">Note</a>
<code>first</code> 와 <code>last</code> 둘 다 포함되어 있을 때, 위의 알고리즘에 따르면 두 필드 모두 set여야 합니다만, 페이지네이션에 관한 의미는 불분명해집니다. 이는 <code>first</code>와 <code>last</code> 두 개 모두 사용하여 페이지네이션을 권장하지 않은 이유 중 하나입니다.</div>
<p><code>startCursor</code>와 <code>endCursor</code>는 각각 <code>edges</code>의 첫 번째와 마지막 노드에 해당되는 커서여야 합니다.</p>
<div id="note-c4c51" class="spec-note">
<a href="#note-c4c51">Note</a>
이 스펙은 Relay Classic을 염두에 두고 만들어진 것이므로, Relay Legacy는 <code>startCursor</code> 와 <code>endCursor</code>를 정의하지 않았다는 점과 각각의 에지에서 <code>cursor</code>를 선택하는 것에 의존했다는 점은 주목할 만합니다. Relay Modern은 대역폭을 절약하는 것 대신에(그 사이에 커서를 사용하지 않기 때문에), <code>startCursor</code> 와 <code>endCursor</code>을 선정하기 시작했습니다.</div>
</section>
<section id="sec-PageInfo.-" secid="5.2">
<h3><span class="spec-secid" title="link to this section"><a href="#sec-PageInfo.-">5.2</a></span>스키마 확인</h3>
<p>위의 요구사항을 정확하게 충족하는 서버는 아래의 스키마 확인 쿼리를 받아들이고 주어진 응답을 제공합니다.</p>
<pre><code><span class="token punctuation">{</span>
  __type<span class="token punctuation">(</span><span class="token attr-name">name</span><span class="token punctuation">:</span> <span class="token string">"PageInfo"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fields <span class="token punctuation">{</span>
      name
      <span class="token keyword">type</span> <span class="token punctuation">{</span>
        name
        kind
        ofType <span class="token punctuation">{</span>
          name
          kind
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>리턴</p>
<pre><code><span class="token punctuation">{</span>
  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"__type"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token property">"fields"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token comment">// May contain other fields.</span>
        <span class="token punctuation">{</span>
          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"hasNextPage"</span><span class="token punctuation">,</span>
          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>
            <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"NON_NULL"</span><span class="token punctuation">,</span>
            <span class="token property">"ofType"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Boolean"</span><span class="token punctuation">,</span>
              <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"SCALAR"</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span>
          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"hasPreviousPage"</span><span class="token punctuation">,</span>
          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>
            <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"NON_NULL"</span><span class="token punctuation">,</span>
            <span class="token property">"ofType"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Boolean"</span><span class="token punctuation">,</span>
              <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"SCALAR"</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span>
          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"startCursor"</span><span class="token punctuation">,</span>
          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>
            <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"NON_NULL"</span><span class="token punctuation">,</span>
            <span class="token property">"ofType"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"String"</span><span class="token punctuation">,</span>
              <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"SCALAR"</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span>
          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"endCursor"</span><span class="token punctuation">,</span>
          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token null keyword">null</span><span class="token punctuation">,</span>
            <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"NON_NULL"</span><span class="token punctuation">,</span>
            <span class="token property">"ofType"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
              <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"String"</span><span class="token punctuation">,</span>
              <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"SCALAR"</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</section>
</section>
<section id="index" secid="index" class="spec-index"><h1><span class="spec-secid" title="link to the index"><a href="#index">§</a></span>Index</h1><ol><li><a href="#ApplyCursorsToEdges()">ApplyCursorsToEdges</a></li><li><a href="#EdgesToReturn()">EdgesToReturn</a></li><li><a href="#HasNextPage()">HasNextPage</a></li><li><a href="#HasPreviousPage()">HasPreviousPage</a></li></ol></section></article>
<footer>
Written in <a href="https://spec-md.com" target="_blank">Spec Markdown</a>.</footer>
<input hidden class="spec-sidebar-toggle" type="checkbox" id="spec-sidebar-toggle" aria-hidden /><label for="spec-sidebar-toggle" aria-hidden>&#x2630;</label>
<div class="spec-sidebar" aria-hidden>
<div class="spec-toc">
<div class="title"><a href="#">GraphQL 커서 연결 사양</a></div>
<ol><li id="_sidebar_1"><a href="#sec-undefined.-"><span class="spec-secid">1</span>예약된 타입</a></li>
<li id="_sidebar_2"><a href="#sec-undefined.-"><span class="spec-secid">2</span>커넥션 타입</a>
<input hidden class="toggle" type="checkbox" id="_sidebar_toggle_2" /><label for="_sidebar_toggle_2"></label>
<ol>
<li id="_sidebar_2.1"><a href="#sec-undefined.-.-"><span class="spec-secid">2.1</span>필드</a>
<input hidden class="toggle" type="checkbox" id="_sidebar_toggle_2.1" /><label for="_sidebar_toggle_2.1"></label>
<ol>
<li id="_sidebar_2.1.1"><a href="#sec-undefined.-.-.-"><span class="spec-secid">2.1.1</span>엣지</a></li>
<li id="_sidebar_2.1.2"><a href="#sec-PageInfo-"><span class="spec-secid">2.1.2</span>PageInfo 필드</a></li>
</ol>
</li>
<li id="_sidebar_2.2"><a href="#sec-undefined.-.-"><span class="spec-secid">2.2</span>스키마 확인</a></li>
</ol>
</li>
<li id="_sidebar_3"><a href="#sec-undefined.-"><span class="spec-secid">3</span>엣지 타입</a>
<input hidden class="toggle" type="checkbox" id="_sidebar_toggle_3" /><label for="_sidebar_toggle_3"></label>
<ol>
<li id="_sidebar_3.1"><a href="#sec-undefined.-.-"><span class="spec-secid">3.1</span>필드</a>
<input hidden class="toggle" type="checkbox" id="_sidebar_toggle_3.1" /><label for="_sidebar_toggle_3.1"></label>
<ol>
<li id="_sidebar_3.1.1"><a href="#sec-undefined.-.-.-"><span class="spec-secid">3.1.1</span>노드</a></li>
<li id="_sidebar_3.1.2"><a href="#sec-undefined.-.-.-"><span class="spec-secid">3.1.2</span>커서</a></li>
</ol>
</li>
<li id="_sidebar_3.2"><a href="#sec-undefined.-.-"><span class="spec-secid">3.2</span>스키마 확인</a></li>
</ol>
</li>
<li id="_sidebar_4"><a href="#sec-undefined.-"><span class="spec-secid">4</span>인수</a>
<input hidden class="toggle" type="checkbox" id="_sidebar_toggle_4" /><label for="_sidebar_toggle_4"></label>
<ol>
<li id="_sidebar_4.1"><a href="#sec-undefined.-.-"><span class="spec-secid">4.1</span>정방향 페이지네이션의 인수</a></li>
<li id="_sidebar_4.2"><a href="#sec-undefined.-.-"><span class="spec-secid">4.2</span>역방향 페이지네이션의 인수</a></li>
<li id="_sidebar_4.3"><a href="#sec-undefined.-.-"><span class="spec-secid">4.3</span>엣지 순서</a></li>
<li id="_sidebar_4.4"><a href="#sec-undefined.-.-"><span class="spec-secid">4.4</span>페이지네이션 알고리즘</a></li>
</ol>
</li>
<li id="_sidebar_5"><a href="#sec-PageInfo"><span class="spec-secid">5</span>PageInfo</a>
<input hidden class="toggle" type="checkbox" id="_sidebar_toggle_5" /><label for="_sidebar_toggle_5"></label>
<ol>
<li id="_sidebar_5.1"><a href="#sec-PageInfo.-"><span class="spec-secid">5.1</span>필드</a></li>
<li id="_sidebar_5.2"><a href="#sec-PageInfo.-"><span class="spec-secid">5.2</span>스키마 확인</a></li>
</ol>
</li>
<li id="_sidebar_index"><a href="#index"><span class="spec-secid">§</span>Index</a></li>
</ol>
</div>
<script>(function(){for(var e,t=[],n=document.getElementsByTagName("section"),o=0;o<n.length;o++)n[o].getAttribute("secid")&&t.push(n[o]);var i=window.scrollY,r=!1;function c(n){for(var o,i=n+document.documentElement.clientHeight/4,r=t.length-1;r>=0;r--)if(t[r].offsetTop<i){o=t[r];break}var c=o&&o.getAttribute("secid");c!==e&&(e&&d(e,!1),c&&d(c,!0),e=c)}function d(e,t){document.getElementById("_sidebar_"+e).className=t?"viewing":"";for(var n=e.split(".");n.length;){var o=document.getElementById("_sidebar_toggle_"+n.join("."));o&&(o.checked=t),n.pop()}}window.addEventListener("scroll",(function(e){i=window.scrollY,r||(r=!0,window.requestAnimationFrame((function(){c(i),r=!1})))})),c(window.scrollY);})()</script>
</div>
</body>
</html>
